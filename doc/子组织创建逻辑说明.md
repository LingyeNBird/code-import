# 子组织创建逻辑说明

## 概述

本文档详细介绍代码迁移工具中子组织（SubGroup）的创建逻辑，包括算法设计、性能优化和关键实现细节。

## 背景

在代码迁移过程中，源平台的仓库可能位于多层级的组织结构中，例如：
- `device/generic/trusty`
- `device/generic/car`
- `device/google/dragon`

目标平台需要重建这种组织结构，确保：
1. 所有父级组织按顺序创建（父级必须先于子级存在）
2. 避免重复创建已存在的组织
3. 性能优化，减少不必要的API调用

## 组织结构说明

### 根组织
- 根组织由用户**手动提前创建**，例如 `cnb`
- 工具不负责创建根组织，仅在根组织下创建子组织
- 配置项：`cnb.root_organization`

### 子组织
- 子组织是根组织下的多层级组织结构
- 仓库路径中**不包含根组织名称**
- 例如仓库路径 `device/generic/trusty` 需要创建：
  - `cnb/device`（一级子组织）
  - `cnb/device/generic`（二级子组织）
  - `cnb/device/generic/trusty`（三级子组织）

## 核心流程

子组织创建的主函数是 `CreateSubOrganizationIfNotExists`，采用四步策略：

```
待迁移仓库列表
      ↓
1. 收集并去重子组织路径
      ↓
2. 获取现有子组织列表
      ↓
3. 过滤出需要创建的子组织
      ↓
4. 按层级深度顺序创建
```

### 第一步：收集并去重子组织路径

**函数**：`collectUniqueSubGroups(depotList []vcs.VCS) map[string]*vcs.SubGroup`

**目的**：从所有仓库路径中提取唯一的子组织路径，包括所有父级路径

**算法逻辑**：

```go
输入：depotList = [
    {RepoPath: "device/generic/trusty", ...},
    {RepoPath: "device/generic/car", ...},
    {RepoPath: "device/google/dragon", ...}
]

处理过程：
对每个仓库的子组织路径（如 "device/generic/trusty"）：
1. 按 "/" 分割为 ["device", "generic", "trusty"]
2. 逐层构建路径并添加到 map：
   - i=0: tmpPath = "device" → 添加
   - i=1: tmpPath = "device/generic" → 添加
   - i=2: tmpPath = "device/generic/trusty" → 添加

输出：uniqueSubGroups = {
    "device": {...},
    "device/generic": {...},
    "device/generic/trusty": {...},
    "device/google": {...},
    "device/google/dragon": {...}
}
```

**关键设计**：
- 使用 `map[string]*vcs.SubGroup` 自动去重
- 保留最深层的原始 `SubGroup` 信息（Desc、Remark）
- 父级组织继承子级的描述和备注

**代码示例**：
```go
for i, part := range parts {
    if tmpPath == "" {
        tmpPath = part  // 第一层直接赋值
    } else {
        tmpPath = path.Join(tmpPath, part)  // 拼接路径
    }
    
    if _, exists := uniqueSubGroups[tmpPath]; !exists {
        if i == len(parts)-1 {
            // 最深层使用原始信息
            uniqueSubGroups[tmpPath] = subGroup
        } else {
            // 父级继承信息但调整 Name 字段
            parentSubGroup := &vcs.SubGroup{
                Name:   tmpPath,
                Desc:   subGroup.Desc,
                Remark: subGroup.Remark,
            }
            uniqueSubGroups[tmpPath] = parentSubGroup
        }
    }
}
```

### 第二步：获取现有子组织列表

**函数**：`GetSubGroupsByRootGroup(url, token string) (map[string]bool, error)`

**目的**：一次性获取目标平台上所有已存在的子组织，避免重复创建

**实现方式**：
- 分页获取根组织下的所有子组织
- 递归获取多层级子组织（通过 `getAllSubGroupsRecursively`）
- 返回 `map[string]bool` 用于快速查找

**关键点**：
- 使用分页机制处理大量子组织
- 递归遍历所有层级，确保完整获取
- 时间复杂度：O(n)，n 为现有子组织数量

### 第三步：过滤需要创建的子组织

**函数**：`filterSubGroupsToCreate(uniqueSubGroups, existingSubGroups) map[string]*vcs.SubGroup`

**目的**：对比步骤1和步骤2的结果，找出需要新建的子组织

**算法**：
```go
toCreate := make(map[string]*vcs.SubGroup)
for subGroupPath, subGroup := range uniqueSubGroups {
    if !existingSubGroups[subGroupPath] {
        toCreate[subGroupPath] = subGroup
    }
}
```

**时间复杂度**：O(k)，k 为唯一子组织数量

### 第四步：按层级深度顺序创建

**函数**：`createSubGroupsSequentially(url, token, toCreate) error`

**目的**：确保父级组织先于子级创建，避免"父组织不存在"错误

**排序策略**：
1. 按路径中斜杠 `/` 数量排序（表示层级深度）
2. 深度相同时按字母顺序排序

**示例**：
```
排序前：
["device/generic/trusty", "device", "device/google/dragon", "device/generic"]

排序后：
["device", "device/generic", "device/google", "device/generic/trusty", "device/google/dragon"]
深度0      深度1           深度1        深度2                   深度2
```

**创建逻辑**：
```go
sort.Slice(paths, func(i, j int) bool {
    depthI := strings.Count(paths[i], "/")
    depthJ := strings.Count(paths[j], "/")
    if depthI != depthJ {
        return depthI < depthJ  // 深度小的在前
    }
    return paths[i] < paths[j]  // 深度相同按字母排序
})

for _, subGroupPath := range paths {
    err := CreateSubOrganization(url, token, subGroupPath, *subGroup)
    if err != nil {
        if strings.Contains(err.Error(), "已存在") {
            continue  // 跳过已存在的组织
        }
        return err  // 其他错误直接返回
    }
}
```

## 性能优化

### 优化前的问题
- 对每个仓库都调用API检查组织是否存在
- 重复创建同一个父级组织
- 时间复杂度：O(n * m)，n为仓库数，m为平均组织层级

### 优化后的改进
1. **预处理去重**：O(n) 时间收集所有唯一组织
2. **批量获取**：O(1) 次 API 调用获取现有组织列表
3. **高效过滤**：O(k) 时间过滤需要创建的组织
4. **顺序创建**：O(k) 时间创建新组织

### 实际效果
假设 100 个仓库，平均 3 层组织结构：
- **优化前**：API 调用约 1100 次（每个仓库 11 次）
- **优化后**：API 调用约 101 次（1次获取 + 约100次创建）
- **性能提升**：约 11 倍

## 错误处理

### 常见错误场景

1. **父组织不存在**
   - 原因：创建顺序错误
   - 解决：通过深度排序确保父级先创建

2. **组织已存在**（errcode: 10010）
   - 处理：记录日志并跳过，继续创建下一个

3. **仓库占用组织名称**（errcode: 10009）
   - 处理：返回错误提示用户手动重命名或删除仓库

4. **API 调用失败**
   - 处理：返回详细错误信息，中断创建流程

### 容错机制
```go
if statusCode == 409 {
    if apiErr.ErrCode == 10009 {
        return fmt.Errorf("仓库与要创建的子组织冲突，请先重命名或删除该仓库")
    }
    // 组织已存在，继续
    return nil
}
```

## 数据结构

### SubGroup 结构
```go
type SubGroup struct {
    Name   string  // 组织路径，如 "device/generic"
    Desc   string  // 描述信息
    Remark string  // 备注信息
}
```

### CreateOrganization 请求体
```go
type CreateOrganization struct {
    Path        string  // 完整路径，如 "cnb/device/generic"
    Description string  // 描述（限制200字符）
    Remark      string  // 备注（限制50字符）
}
```

## 配置项

| 配置项 | 说明 | 默认值 |
|--------|------|--------|
| `cnb.root_organization` | 根组织名称 | - |
| `cnb.url` | 目标平台URL | - |
| `cnb.token` | 访问令牌 | - |
| `PageSize` | 分页大小 | 100 |
| `GroupDescLimitSize` | 组织描述最大长度 | 200 |
| `GroupRemarkLimitSize` | 组织备注最大长度 | 50 |

## 使用示例

```go
// 创建子组织（在迁移流程中自动调用）
err := CreateSubOrganizationIfNotExists(
    CnbApiURL,
    CnbToken,
    depotList,  // 待迁移的仓库列表
)
if err != nil {
    return fmt.Errorf("创建子组织失败: %v", err)
}
```

## 注意事项

1. **根组织必须手动创建**：工具不会创建根组织，请确保在运行前手动创建

2. **单线程顺序执行**：避免并发创建导致的父子组织顺序问题

3. **路径规范化**：组织路径自动转换为小写并移除特殊字符

4. **字段长度限制**：
   - 描述超过 200 字符会自动截断
   - 备注超过 50 字符会自动截断

5. **幂等性**：重复执行不会产生副作用，已存在的组织会被跳过

## 调试建议

查看详细日志可以了解创建过程：
```
预处理完成，发现 5 个唯一子组织
需要创建 3 个新的子组织
开始创建子组织 cnb/device
成功创建子组织 device (1/3)
开始创建子组织 cnb/device/generic
成功创建子组织 device/generic (2/3)
子组织 device/google 已存在，跳过
子组织创建完成，共创建 2 个
```

## 总结

子组织创建逻辑通过预处理去重、批量获取、深度排序三个关键步骤，实现了：
- ✅ 正确的创建顺序（父级优先）
- ✅ 避免重复创建
- ✅ 性能优化（减少 API 调用）
- ✅ 容错机制（处理已存在等异常）
- ✅ 幂等性（可重复执行）

这种设计使得即使面对复杂的多层级组织结构，也能高效、准确地完成迁移任务。
